#!/bin/bash

#if [ "$DOPS_SHELL" = "stage1" ]; then
#  unset DOPS_SHELL
#else
#  export DOPS_SHELL=stage1
#  export DOPS_DIR="$(cd "$(dirname "$0")"; echo $PWD)"
#  redo-ifchange "$DOPS_DIR/redo-sh"
#  exec "$DOPS_DIR/redo-sh" "$0" "$@"
#fi

: ${DOPS_DIR:="$(dirname "$(readlink -f "$0")")"}
: ${DOPS_ROOT:="$(cd "$DOPS_DIR/.."; echo $PWD)"}
: ${DOPS_CONF:="$DOPS_ROOT/conf"}
: ${DOPS_MYCONF:="$DOPS_CONF/${PWD##*/}"}
: ${DOPS_NODE_ID:="$(cd "$DOPS_ROOT"; cat $(git rev-parse --git-dir)/info/dops_node_id 2>/dev/null)"}

if [ -z "$DOPS_BIN_DIR" ]; then
  export DOPS_BIN_DIR="$DOPS_DIR/bin"
  export PATH="$DOPS_BIN_DIR:$PATH"
fi

warn(){
  if [ "a$1" = "a-n" ]; then
    shift
    printf "$@" >&2
  else
    local templ="$1"
    shift
    printf "$templ\n" "$@" >&2
  fi
}

fail(){
  warn "$@"
  exit 1
}

has(){
  which "$@" >/dev/null 2>&1
}

contains(){
  grep "$@" >/dev/null 2>&1
}

econtains(){
  egrep "$@" >/dev/null 2>&1
}

fcontains(){
  fgrep "$@" >/dev/null 2>&1
}

shquote(){
	local HEAD TAIL="$*"
	printf "'"

	while [ -n "$TAIL" ]; do
		HEAD="${TAIL%%\'*}"

		if [ "$HEAD" = "$TAIL" ]; then
			printf "%s" "$TAIL"
			break
		fi

		printf "%s'\"'\"'" "$HEAD"

		TAIL="${TAIL#*\'}"
	done

	printf "'"
}

redo-cat(){
  redo-ifchange "$@"
  cat "$@"
}

redo-catx(){
  ( set +e
    redo-ifchange "$@"
    local v
    for v in "$@"; do
      if ! [ -e "$v" ]; then
        redo-ifcreate "$v"
      fi
    done
    cat "$@" 2>/dev/null
  )
  return 0
}

redo-source(){
  redo-ifchange "$@"
  while [ $# -gt 0 ]; do
		. "$1"
		shift
	done
}

redo-source-cat(){
  redo-ifchange "$@"
  while [ $# -gt 0 ]; do
		. "$1"
		cat "$1"
		shift
	done
}

# do-record var default-val val
do-record(){
  local val="${3:-"$2"}"
  eval $1='$val'
  printf "%s\n" "$1=$(shquote "$val")"
}

# do-recordf var default-val valfile
do-recordf(){
  do-record "$1" "$2" "$(redo-catx "$3")"
}

# do-recordc var default-val
do-recordc(){
  do-recordf "$1" "$2" "$DOPS_CONF/$(basename "$PWD")/$1"
}

dopsh-init(){
  zero="$(basename "$0")"
  DOPSH_CALL_DIR="$PWD"
  cd "$(dirname "$DOPSH_DO_FILE")"
}

dopsh-parseopt(){
  local template=" $1 "
  shift
  declare -a opts
  while [ $# -gt 0 ]; do
    local s=1
    local arg=
    case "$1" in
      --*|-*|--*=*|-*=*)
        arg="${1#*-}"
        val="${arg#*=}"
        arg="${arg%%=*}"
        if [[ "${template// +$arg /}" != "$template" ]]; then
          s=1
          : "${val:=true}"
          if [[ $val != true ]] && [[ $val != false ]]; then
            echo "Expected true or valse for --$arg" >&2
            return 1
          fi
          eval "op_${arg}=$val"
          arg="+$arg"
        else
          if [[ "${1%%=*}" != "$1" ]]; then
            val="$2"
            s=2
          else
            s=1
          fi
          eval "declare -a op_${arg}s"
          eval "op_${arg}s=(\"\${${arg}s[@]}\" \"\$val\")"
          eval "op_${arg}=\"\$val\""
          arg="$arg="
        fi
        ;;
      -no-*|--no-)
        s=1
        arg="${1#*no-}"
        eval "op_${arg}=false"
        arg="+$arg"
        ;;
      --)
        s=0
        shift
        opts=("${opts[@]}" "$@")
        break
        ;;
      *)
        opts=("${opts[@]}" "$1")
        shift
        ;;
    esac
    if [[ -n "$arg" ]] && [[ "${template// $arg /}" = "$template" ]]; then
      echo "Unknown argument $1" >&2
      return 1
    fi
    shift $s
  done
  local op
  local n=1
  for op in $template; do
    if [[ "${op#+}" != "$op" ]]; then
      :
    elif [[ "${op%=}" != "$op" ]]; then
      :
    elif [[ $n -gt "${#opts}" ]]; then
      echo "Missing argument $op" >&2
      return 1
    else
      eval "op_$op=\"\${opts[$n]}\""
    fi
  done
}

DOPSH_STAMP=false
redo-always-stamp(){
  redo-always
  DOPSH_STAMP=true
}

DOPSH_DO_FILE="$1"
shift

(
  [ -n "$REDO_XTRACE" ] && set -x
  [ -n "$REDO_VERBOSE" ] && set -v
  set -e
  source "$DOPSH_DO_FILE"
)
res=$?

if $DOPSH_STAMP; then
  redo-stamp <"$3"
fi

exit $res
