#!/bin/bash

#if [ "$DOPS_SHELL" = "stage1" ]; then
#  unset DOPS_SHELL
#else
#  export DOPS_SHELL=stage1
#  export DOPS_DIR="$(cd "$(dirname "$0")"; echo $PWD)"
#  redo-ifchange "$DOPS_DIR/redo-sh"
#  exec "$DOPS_DIR/redo-sh" "$0" "$@"
#fi

: ${DOPS_DIR:="$(dirname "$(readlink -f "$0")")"}
: ${DOPS_ROOT:="$(cd "$DOPS_DIR/.."; echo $PWD)"}
: ${DOPS_CONF:="$DOPS_ROOT/conf"}
: ${DOPS_MYCONF:="$DOPS_CONF/${PWD##*/}"}
: ${DOPS_NODE_ID:="$(cd "$DOPS_ROOT"; cat $(git rev-parse --git-dir)/info/dops_node_id 2>/dev/null)"}

if [ -z "$DOPS_BIN_DIR" ]; then
  export DOPS_BIN_DIR="$DOPS_DIR/bin"
  export PATH="$DOPS_BIN_DIR:$PATH"
fi

warn(){
  if [ "a$1" = "a-n" ]; then
    shift
    printf "$@" >&2
  else
    local templ="$1"
    shift
    printf "$templ\n" "$@" >&2
  fi
}

fail(){
  warn "$@"
  exit 1
}

has(){
  which "$@" >/dev/null 2>&1
}

contains(){
  grep "$@" >/dev/null 2>&1
}

econtains(){
  egrep "$@" >/dev/null 2>&1
}

fcontains(){
  fgrep "$@" >/dev/null 2>&1
}

shquote(){
	local HEAD TAIL="$*"
	printf "'"

	while [ -n "$TAIL" ]; do
		HEAD="${TAIL%%\'*}"

		if [ "$HEAD" = "$TAIL" ]; then
			printf "%s" "$TAIL"
			break
		fi

		printf "%s'\"'\"'" "$HEAD"

		TAIL="${TAIL#*\'}"
	done

	printf "'"
}

redo-cat(){
  redo-ifchange "$@"
  cat "$@"
}

redo-catx(){
  ( set +e
    redo-ifchange "$@"
    local v
    for v in "$@"; do
      if ! [ -e "$v" ]; then
        redo-ifcreate "$v"
      fi
    done
    cat "$@" 2>/dev/null
  )
  return 0
}

redo-source(){
  redo-ifchange "$@"
  while [ $# -gt 0 ]; do
		. "$1"
		shift
	done
}

redo-source-cat(){
  redo-ifchange "$@"
  while [ $# -gt 0 ]; do
		. "$1"
		cat "$1"
		shift
	done
}

# do-record var default-val val
do-record(){
  local val="${3:-"$2"}"
  eval $1='$val'
  printf "%s\n" "$1=$(shquote "$val")"
}

# do-recordf var default-val valfile
do-recordf(){
  do-record "$1" "$2" "$(redo-catx "$3")"
}

# do-recordc var default-val
do-recordc(){
  do-recordf "$1" "$2" "$DOPS_CONF/$(basename "$PWD")/$1"
}

dopsh-init(){
  DOPSH_CALL_DIR="$PWD"
  cd "$(dirname "$DOPSH_DO_FILE")"
}

dopsh-usage(){
  local help=false
  echo -n "$DOPSH_ARG0"
  for op in $template; do
    local op2="${op#-}"
    if [[ "${op2%=}" != "$op2" ]]; then
      echo -n " -${op2}?"
    elif [[ "$op2" != "$op" ]]; then
      echo -n " -$op"
    elif [[ "${op#h:}" != "$op" ]] || [[ "${op#H:}" != "$op" ]]; then
      help=true
    else
      echo -n " $(tr a-z A-Z <<<"$op")"
    fi
  done
  echo
  if $help; then
    echo -n "$DOPSH_ARG0"
    for op in $template; do
      if [[ "${op#h:}" != "$op" ]]; then
        echo -n " --${op#h:}"
      elif [[ "${op#H:}" != "$op" ]]; then
        echo -n " --${op#H:}"
      fi
    done
    echo " (show this help)"
  fi
}

dopsh-parseopt(){
  local template=" $1 "
  shift
  opts=()
  while [ $# -gt 0 ]; do
    local s=1
    local arg=
    local val
    local op
    case "$1" in
      -no-*|--no-*)
        s=1
        arg="${1#*-no-}"
        eval "op_${arg}=false"
        arg="-$arg"
        ;;
      --*|-*|--*=*|-*=*)
        op="${1#-}"
        op="${op#-}"
        val="${op#*=}"
        if [[ "a$val" = "a$op" ]]; then
          val=""
        fi
        arg="${op%%=*}"
        if [[ "${template// h:$op /}" != "$template" ]]; then
          # if option is help
          dopsh-usage "$template"
          eval "op_${arg}=true"
          return 0
        elif [[ "${template// H:$op /}" != "$template" ]]; then
          # if option is help
          dopsh-usage "$template"
          eval "op_${arg}=true"
          return 1
        elif [[ "${template// -$arg /}" != "$template" ]]; then
          # if option is boolean
          s=1
          : "${val:=true}"
          if [[ $val != true ]] && [[ $val != false ]]; then
            echo "Expected true or false for --$arg" >&2
            dopsh-usage "$template" >&2
            return 1
          fi
          eval "op_${arg}=$val"
          arg="-$arg"
        else
          #else: option is not boolean, expect a value
          if [[ "${1%%=*}" != "$1" ]]; then
            s=1
          else
            val="$2"
            s=2
          fi
          eval "declare -a op_${arg}s"
          eval "op_${arg}s=(\"\${${arg}s[@]}\" \"\$val\")"
          eval "op_${arg}=\"\$val\""
          arg="-$arg="
        fi
        ;;
      --)
        s=0
        shift
        opts=("${opts[@]}" "$@")
        break
        ;;
      *)
        s=1
        opts=("${opts[@]}" "$1")
        ;;
    esac
    if [[ -n "$arg" ]] && [[ "${template// $arg /}" = "$template" ]]; then
      echo "Unknown argument $1" >&2
      dopsh-usage "$template" >&2
      return 1
    fi
    shift $s
  done
  local op
  local n=1
  for op in $template; do
    local op2="${op#-}"
    if [[ "${op2%=}" != "$op2" ]]; then
      :
    elif [[ "$op2" != "$op" ]]; then
      eval ": \${op_$op2:=false}"
    elif [[ "${op#h:}" != "$op" ]]; then
      eval ": \${op_${op#h:}:=false}"
    elif [[ "${op#H:}" != "$op" ]]; then
      eval ": \${op_${op#h:}:=false}"
    elif [[ "${op%\*}" != "$op" ]]; then
      local nam="${op%\*}"
      eval "op_${nam}s=()"
      while [[ $n -le "${#opts[@]}" ]]; do
        eval "op_${nam}s=(\"\${op_${nam}s[@]}\" \"\${opts[$n-1]}\")"
        let n=n+1
      done
    elif [[ $n -gt "${#opts[@]}" ]]; then
      echo "Missing argument $op" >&2
      dopsh-usage "$template" >&2
      return 1
    elif [[ "${op%+}" != "$op" ]]; then
      local nam="${op%+}"
      eval "op_${nam}s=()"
      while [[ $n -le "${#opts[@]}" ]]; do
        eval "op_${nam}s=(\"\${op_${nam}s[@]}\" \"\${opts[$n-1]}\")"
        let n=n+1
      done
    else
      eval "op_$op=\"\${opts[$n-1]}\""
      let n=n+1
    fi
  done
}

redo-always-stamp(){
  redo-always
  local in=${1:-${DOPSH_ARGS[2]}}
  if [ "a$in" = "a-" ]; then
    redo-stamp
  else
    redo-stamp <"$in" 
  fi
}

DOPSH_ARG0="$1"
shift
DOPSH_ARGS=("$@")

(
  [ -n "$REDO_XTRACE" ] && set -x
  [ -n "$REDO_VERBOSE" ] && set -v
  set -e
  source "$DOPSH_ARG0"
)
exit $?

